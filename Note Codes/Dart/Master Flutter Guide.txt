# Creating the main() function of your flutter app.
//example:
void main() => startApp(MaterialApp(
	home: *name of your class*()
));

// void main() is the fuction that our app will run first.
// startApp() is a function that runs a widget at the startup.

# Creating a stateless widget.
1. Type "stless" and it will automatically create the code for you.
2. Name the class.
3. Return a widget. Preferrably Scaffold().

//example:
class *any name* extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
		//put anything here.
    );
  }
}

# Creating a statful widget.
1. Type "stful" and it will automatically create the code for you.
2. Name the class.
3. Return a widget in the second created class. Preferrably Scaffold().

//example:
class Test extends StatefulWidget {
  @override
  _TestState createState() => _TestState();
}

class _TestState extends State<Test> {
  //intialize any data here.
  @override
  Widget build(BuildContext context) {
    return Scaffold(
		//put anything here.
	);
  }
}

# Converting to stateful/stateless widget.
1. Just click the state after the "extend".
2. Choose your new state. 

# How to display data in your widgets.
//example:
int ctr = 0;
*when using in widget*
"$ctr"
//always use in a string then put a dollar sign before the variable.

# When manipulating data in a function. Always put your code in the setState(() {}). It also works even if the function is empty.
//example:
onPressed: () {
          setState(() {
            myLevel = myLevel+1;
            print("Log: Added some level!");
          });
		  

*name_of_variable is a list.
*any_variable_name will act as a receiver of data from the list.
		  
# Creating your own class.
1. Create a new file. (first letter should be a smaller case)
2. The class name should be the same with 
   the file name but the first letter should be upper case.
2. Initialize your variables.
3. Import your file to your main class.

"Note: Creating your own class is like creating your own data type with different properties."
//example(creating your own class)
class Person
{
	String name;
	String age;
	
	Person({this.name , this.age})
}
//example(importing)
import "person.dart";

# Assigning data to your class (mostly done in a list).
List<Person> people = [
	Person(name: "Jedidiah",age: "20")
	]

# When getting a data from the property of a custom class.
1. Should be inside the ${object.property}
//example
children: people.map((human){
return Text("Name is ${human.name}, ${human.age} years old.")
})

# Creating a Widget Class.
1. Create a new file. Name it the same with the name of the class. (Lowercase for convention's sake)
2. Create a stateless widget. The class name should be uppercase. 
3. Create a final variable name of the object that will be used.
4. Create a constructor that gives data to the final variable.
5. Import the files imported by the main file.
//example
class QuoteTemplate extends StatelessWidget {
  final Quotes myQuote;
  QuoteTemplate({this.myQuote});

  @override
  Widget build(BuildContext context) {
    return Text(myQuote.author);
  }
}

// example for when calling a widget class.
children: myQuote.map((x) {
		return QuoteTemplate(myQuote: x);
	  }).toList(),

# Creating a function object.
1. Create a function object.
2. This is mostly created in custom widgets.
//example
final Function delete; 

Notes: 
1. "delete" is the variable name
2. "Function" is an object.

// example when delivering the data of the custom function from the main class
children: myQuote.map((x) {
                return QuoteTemplate(
                    myQuote: x, //disregard this. focus on the delete
                    delete: () {
                      setState(() {
                        myQuote.remove(x);
                      });
                    }
                );
              }).toList(),

// example when calling the function from the custom class
onPressed: () 
{
     delete();
}

# Creating multiple pages and how to navigate through them.
1. Create custom classes then import the material app in each file. 
2. In your main class, create a routes property. (Go to the MaterialApp() section in order to understand on how to use this property.)
3. Put some destination in your routes property. 
4. In order to navigate to a page, add a Navigator. object to the function of a particular button.
   //example:
	onPressed: () {
		Navigator.pushNamed(context, "/whateverlocation"); //stacks to the current screen
		/or/
		Navigator.pushReplacedNamed(context, "/whateverlocation"); //replaces the current screen
		/or/
		Naviagtor.pop(context, {}) //goes back to the initial screen
	}
	
# Passing data to other page.
1. Add an additional argument named "arguments:" to the Navigator. object. //when popping, "arguments: " is not needed anymore.
2. Put a map inside the argument. 
	//example:
	onPressed: () {
		Navigator.pushReplacedNamed(context, "/whateverlocation",arguments: {
			'location' : wt.location,
			'flag' : wt.flag,
			'currentTime' : wt.currentTime,
		}); 
	}
3. Go to the page that you will navigate into.
4. Initialize a map data. (outside of build)
5. Give the map variable a ModalRoute. object. (inside the build)
	//example:
	class _HomeState extends State<Home> {

	  Map myData;

	  @override
	  Widget build(BuildContext context) {
		myData = ModalRoute.of(context).settings.arguments;
		return Scaffold()
	  }
 
 # Navigator Pop and Data Return Combo
 1. From the main class:
		onPressed: () async 
		{
		  dynamic result = await Navigator.pushNamed(context,"/chooseLocation");
		  myData = {
			"location": result["location"],
			"currentTime": result["currentTime"]
			};
			setState(() {});
		}
2. From the other class:
		Navigator.pop(context, 
		{
        "location": wt.location,
        "currentTime": wt.currentTime,
		});

# Implementing a function that runs once the custom class run.
1. Just right after the class state, type initstate and it will automatically code for you.
2. Remove TO DO line.
	//example:
	@override
	void initState()
	{
		super.initState();
		print("It runs.");
	}

# Creating a Asynchronous function. (A function that runs after several time after.)
1. Create a void function and name it whatever you want.
2. Put a Future. object that handles delayed().
3. Enter a duration and another function inside the delayed property.
4. Then put a "async" right after the function name. (After the "()")
5. If you want to finish a function first before moving on to the next function, put an "await" before the line.
6. Always wrap void with Future.
	//example
	Future<void> delayedRun() async
	  {
		await Future.delayed(Duration(seconds: 3),() {
		  print("3 seconds has passed.");
		});
	  }
	  
# Putting data into variables with Asynchronous function.
1. Initialize a variable then put a Future. object in it. (Including the properties)
2. Inside the nested function, return a value.
3. Do not forget the "async". For some reason, you can't return a value without it.
	//example
	Future<void> delayedRun() async
	{
		String username = await Future.delayed(Duration(seconds: 3),() {
			return "Nostee";
		})
	}
	
# Adding the HTTP package to flutter.
1. Go to pubspec.yaml
2. Under dependencies, add the package, http: ^0.12.0+2
	//example
		dependencies:
		  flutter:
			sdk: flutter
		  http: ^0.12.0+4
 3. Save file then get dependencies on the main class. 
 4. import 'package:http/http.dart' on the file where you're gonna use the http package.
 5. also import 'dart:convert' on the same file.

 # Using the HTTP package.
 1. In a future async function, create a Response object. Name the variable anything you want.
 2. Put an "await" before the get() function.
 3. Inside the get() function, put this: 'https://jsonplaceholder.typicode.com/todos/1'
 4. After the line, create a map object and put inside a jsonDecode() function. 
 5. Inside the jsonDecode() function, get the variable name of your response object and get the "body" property.
 6. You can now call your map variable.
 
 # Creating a date time object.
 1. Let's assume that you already got the property from the world time api and gave it to a String variable.
 2. Create a DateTime object and give it a variable name.
 3. Equate it to an another DateTime. object then parse(). 
 4. Inside the parse function, give it the variable that you assigned the date time property.
 
 # Adding an hour to the date time object.
 1. Get the variable name of your DateTime object then put a ".add()" to it.
 2. Add a Duration() function inside the add() function.
 3. Inside the duration() function, put "hours: " then put an integer right after it. 
	//example:
	Future<void> getTime() async
	  {
		Response manila = await get("http://worldtimeapi.org/api/timezone/Asia/Manila");
		Map time = jsonDecode(manila.body); // getting the properties and putting it in a map
		String date = time["datetime"];	// getting the "datetime" property then putting it in a String
		String offset = time["utc_offset"].substring(1,3); // getting the "utc_offset" property then putting it in a String
														   // getting the numbers only by using substring()

		DateTime dt = DateTime.parse(date); 	// creating a DateTime object.
		dt = dt.add(Duration(hours: int.parse(offset)));	// add an hour to the current DateTime object.
		print("Time in manila is $dt");
	  }
 
# Formatting Dates.
1. Go to pubspec.yaml
2. Under dependencies, add the package, intl: ^0.15.8
	//example
	dependencies:
	  flutter:
		sdk: flutter
	  http: ^0.12.0+2
	  intl: ^0.15.8
3. Save file then get dependencies on the main class. 
4. import 'package:intl/intl.dart' on the file where you're gonna use the intl package.
5. Assign a DateFormat.jm().format() inside a String variable.
	//example:
	currentTime = DateFormat.jm().format(dt); //this is for time only.
 
 # Creating a loading display
1. Go to pubspec.yaml
2. Under dependencies, add the package, flutter_spinkit: ^4.0.0
	//example
	dependencies:
	  flutter:
		sdk: flutter
	  http: ^0.12.0+2
	  intl: ^0.15.8
	  flutter_spinkit: ^4.0.0
3. Save file then get dependencies on the main class. 
4. import 'package:flutter_spinkit/flutter_spinkit.dart' on the file where you're gonna use the flutter_spinkit package.
5. Go to the website: pub.dev/packages/flutter_spinkit and choose a widget and place it in a child property.
	//example
	child: SpinKitRotatingCircle(
	  color: Colors.white,
	  size: 50.0,
	)
	
 # Using ternary operators.
 1. Shorcut if condition looks like this:
	//example:
	bool checker = *condition* ? true : false;

 
"********************WIDGETS********************"

***NOTICE***
// Widgets starts with an UPPERCASE letter.
// Properties starts with a LOWERCASE letter.
// put a comma(,) every after widget/property if you to want to put another widget/property.
******

# Widget: MaterialApp() - it is our main widget.
	Properties:
	> home - it assigns a widget that the app should show first when it is opened.
		   - therefore, you should assign a widget here; Preferrably your own class.
	> routes - it contains a function that handles a map. 
	//example
	routes: {
		"/": (context) => LoadingScreen(),
		"/home": (context) => Home(),
		"/location": (context) => ChooseLocation(),
	}
		Notes: "/" stands for a base route. Basically, the app starts on the base route.
			   "/anything" stands for a route. 
    > initialRoute - It overrides the base route. Do not put with the home property.
				   - It contains a string value of the page. eg. "/home"
	
# Widget: Scaffold() - it wraps our widgets into one whole page.
	Properties:
	> appBar - it is the bar that shows at the very top of the Scaffold().
			 - it contains the widget, AppBar().
	> body - it specifies what should be the content of your scaffold. 
		   - essential to every scaffold.
		   - it should contain a widget.
    > floatingActionButton - it is a button that floats on the bottom right(with a little bit of padding) of the scaffold.
						   - it contains the widget, FloatingActionButton().
	
# Widget: AppBar() - it handles the info of the appBar property.
	Properties:
	> title - it will display a text on the bar using a Text() widget.
	> centerTitle - it contains a boolean(true or false) that decides whether the text is centralized or not.
	> backgroundColor - it paints the widget with an assigned color.
					  - it contains a Color. object: Color.*any color*[*any value*]
							// eg. Colors.red[500] 
	> elevation - set to 0.0 to remove the drop shadow.
	
# Widget: FloatingActionButton() - it handles the info of the floatingActionButton property.
	Properties:
	> onPressed - it contains a function.
					//eg. () {*code here*} 
	> child - it handles a single widget nested into its parent widget.
	> backgroundColor - it paints the widget with an assigned color.
					  - it contains a Color. object: Color.*any color*[*any value*]  
							// eg. Colors.red[500] 
	
# Widget: Text() - it handles a String to be shown and could hold multiple properties.
	Properties:
	> style - it allows to customize the text to be displayed. 
			- it contans the widget, TextStyle().
			
# Widget: TextStyle() - it handles the info of the style property.
	Properties:
	> fontFamily: it contains a String which is the name of your chosen font family. 
	> color - it paints the widget with an assigned color.
			- it contains a Color. object: Color.*any color*[*any value*]  
					// eg. Colors.red[500] 
	> fontSize - it contains a double that determines the size of the font.
	> fontWeight - it contains a FontWeight. object:  FontWeight.*any font weight*
						// eg. FontWeight.bold 
	> letterSpacing - it contains a double that determines the space between the letters.

***USING OTHER FONTS***
1. Create a folder inside the project.
2. Put the downloaded font inside the folder.
3. Edit pubspec.yaml, particularly on the "fonts" section.
4. Click "Get dependencies" on the main class.

//eg. 
fonts: 
	- family: any name you want to give on your font
	  fonts: 
		- asset: path of the font file
******

# Widget: Center() - it centralizes any nested widget inside of it.
	Properties:
	> child - it handles a single widget nested into its parent widget.
	
# Widget: Image() - it handles an image.
	Properties:
	> image - it handles a widget called, AssetImage() or NetworkImage().
	
# Widget: AssetImage() - it handles a string inside the () that loads a local image using its path.
# Widget: NetworkImage() - it handles a string inside the () that loads an online image using its url/location.
	
***USING LOCAL IMAGES***
1. Create a folder inside the project.
2. Put the downloaded image inside the folder.
3. Edit pubspec.yaml, particularly on the "assets" section.
4. Click "Get dependencies" on the main class.

//eg. 
assets: 
	- name of folder/
******
	
# Widget: RaisedButton()/FlatButton()/RaisedButton.icon()/FlatButton.icon()/IconButton() - it is a button with or without a drop shadow and with or without an icon.
						
	Properties:
	> onPressed - it contains a function.
					//eg. () {*code here*} 
	> child - it handles a single widget nested into its parent widget.
	> color - it paints the widget with an assigned color.
			- it contains a Color. object: Color.*any color*[*any value*]  
					// eg. Colors.red[500] 
	if .icon:
	> icon - contains the widget, Icon().
	> label - it sits right next to the icon.
			- it contains the widget, Text().
	
# Widget: Icon() - it handles an Icons. object: Icons.*name of icon* inside its ().
	Properties:
	> color - it paints the widget with an assigned color.
			- it contains a Color. object: Color.*any color*[*any value*]  
					// eg. Colors.red[500] 
	> size	- it contains a double that determines it size.
	
# Widget: Container() - it wraps the widget.
	Properties:
	> color - it paints the widget with an assigned color.
			- it contains a Color. object: Color.*any color*[*any value*]  
					// eg. Colors.red[500] 
	> child - it handles a single widget nested into its parent widget.
	> padding/margin - it gives space surrounding the widget that's inside/outside the container
			  - contains an EdgeInsets. object: EdgeInsets.all[double]
												EdgeInsets.symmetric[horizontal: double,vertical: double]
												EdgeInsets.fromLTRB[double,double,double,double]
	> decoration - it handles the BoxDecoration widget.

# Widget: BoxDecoration() - it handles a image property.
	Properties:
	> image - it handles a DecorationImage widget.
	
# Widget: DecorationImage() - it is used for creating background images in the container.
	Properties:
	> image - it handles an AssetImage() widget.
	> fit - it is used to cover the entire screen. It contains "BoxFit.cover".
												
# Widget: Padding() - it gives space around the child widget.
	Properties:
	> padding - it gives space surrounding the widget.
			  - contains an EdgeInsets. object: EdgeInsets.all[double]
												EdgeInsets.symmetric[horizontal: double,vertical: double]
												EdgeInsets.fromLTRB[double,double,double,double]
	> child - it handles a single widget nested into its parent widget.
	
# Widget: Row() - it wraps multiple widgets horizontally.
	Properties:
	> children - it contains the list, <Widget>[].
			   - the list can contain multiple widgets.
    > mainAxisAlignment - contains a MainAxisAlignment. object: MainAxisAlignment.center
																MainAxisAlignment.spaceBetween
																MainAxisAlignment.spaceEvenly
																MainAxisAlignment.end
	> crossAxisAlignment - contains a CrossAxisAlignment. object: CrossAxisAlignment.stretch
																  CrossAxisAlignment.start
																  CrossAxisAlignment.end
																  
# Widget: Column() - it wraps multiple widgets vertically.
	Properties:
	> children - it contains the list, <Widget>[].
			   - the list can contain multiple widgets.
    > mainAxisAlignment - contains a MainAxisAlignment. object: MainAxisAlignment.center
																MainAxisAlignment.spaceBetween
																MainAxisAlignment.spaceEvenly
																MainAxisAlignment.end
	>crossAxisAlignment - contains a CrossAxisAlignment. object: CrossAxisAlignment.stretch
																  CrossAxisAlignment.start
																  CrossAxisAlignment.end

# Widget: Expanded() - it expands the space consumed by the child widget. Mostly used in Column() and Row().
	Properties:
	> child - it handles a single widget nested into its parent widget.
	> flex - it contains an integer that determines the space consumed shared by the widgets under the Column() or Row().
	
# Widget: SizedBox() - it is an empty box made for giving space between widgets.
	Properties:
	> height - it contains a double that determines its height.
	> width - it contains a double that determines its width.
	
# Widget: CircleAvatar() - it displays an image that's clipped in a circle.
	Properties:
	> backgroundImage - it contains an AssetImage() widget.
	> radius - contains a double that determines its size.
	
# Widget: Divider() - it displays a thin line between two widgets.
	Properties:
	> height - it contains a double that determines its height.
	> color - it paints the widget with an assigned color.
			- it contains a Color. object: Color.*any color*[*any value*]  
					// eg. Colors.red[500] 
	
# Widget: Card() - it acts as a container of a widget in a elevated card form.
	Properties:
	> padding/margin - it gives space surrounding the widget that's inside/outside the card.
		  - contains an EdgeInsets. object: EdgeInsets.all[double]
											EdgeInsets.symmetric[horizontal: double,vertical: double]
											EdgeInsets.fromLTRB[double,double,double,double]
	> child - it handles a single widget nested into its parent widget.
	
# Widget: SafeArea() - it moves the child widget to the screen where we can actually see it.
	Properties:
	> child - it handles a single widget nested into its parent widget.
	
# Widget: ListView.builder() - it display your items in a list.
	Properties:
	> itemCount - it handles an integer that determines the length of your list display.
	> itemBuilder - it contains a function that handles a context,index and an another function that returns a widget.
		//example:
		body: ListView.builder(
			itemCount: variablename.length,
			itemBuilder: (context,index) {
			  return ListTile()
			},

# Widget ListTile() - it handles your items to be displayed in a list.
	Properties:
	> onTap - it handles a function like onPressed.
	> title - it handles a text widget to be displayed.
	> leading - it handles an image to be displayed before the label.
		//example: 
		ListTile(
		onTap: () {}
		title: Text(variablename[index].propertyname)
		)
		
	
	
	
	
	

	