# Setting Up
1. Create this folders inside the "lib" folder.
> loaders // Note: for classes that will load data from the network
> models // Note: for data to be stored. 
> screens // Note: for pages and interface.
> services // Note: for methods and functions related to the particular service.
> shared // Note: for constants
> widgets // Note: for seperate widgets
2. Create the main file for routes.
3. Create an authenticate class. (For authenticating)
4. Create a checker class. (To check if user is authenticated)

Note: Do not put directly the material app in the runApp().

# Adding Firebase to your App
1. Go to the firebase console and click "Add Firebase to your Android App".
2. "Application ID" or "Android Package Name" is in (android/app/build.gradle)
	> minimum sdk ver. should be 21.
3. Follow the instructions there.
4. After everything is done, go to "pubspec.yaml".
5. Add this to dependencies: 
> firebase_auth: ^0.15.5+2
> cloud_firestore: ^0.13.4+2
> firebase_core: ^0.4.4+3
> provider: ^4.0.4

# Create an Authenticator Service
1. Create a new file named auth.dart (or name it whatever u want)
2. import 'package:firebase_auth/firebase_auth.dart';
3. Create a class.
4. Create a Firebase property:
> final FirebaseAuth auth = FirebaseAuth.instance;
5. All methods here should be:
> future and async function.
> try and catch.

# Creating a User Model
1. Create a class in the models folder.
2. Name the class, User.
3. Add a "uid" property that receives the data when called.

# Creating a function that gives a property to the User Model. 
User _userFromFirebase(FirebaseUser user){
      return user != null ? User(uid: user.uid) : null;
  }
  
# Creating a User Change Stream
Stream<User> get user 
{
	return auth.onAuthStateChanged.map(_userFromFirebase);
}
  
Notes:
> User is the custom class made that is in the models folder.
> Its parameter is a FirebaseUser. 
> It returns a data if it received a data. 

# Sign in Anonymously Service Example Code: 
Future<dynamic> signInAnon() async
{
	try
	{
	  AuthResult result = await _auth.signInAnonymously();
	  FirebaseUser user = result.user;
	  return _userFromFirebase(user); 
	}
	catch(e)
	{
	  print(e.toString());
	  return null;
	}
}

# Sign in with Email Example Code:
Future login(String email,String password) async
{
	try
	{
	  AuthResult result = await fba.signInWithEmailAndPassword(email: email, password: password);
	  FirebaseUser user = result.user;
	  return currentUser(user);
	}
	catch(e)
	{
	  return "Failed!";
	}
}

# Sign Out Example Code:
Future signOut() async
{
	try
	{
	  _auth.signOut();
	}
	catch(e)
	{
	  print(e.toString());
	  return null;
	}
}

# Register Example Code:
Future register(String email,String password) async
{
	AuthResult result = await fba.createUserWithEmailAndPassword(email: email, password: password);
	FirebaseUser user = result.user;
}

# UpdateUserData Example Code
Future updateUserData(String sugars,String name,int strength) async
{
	return await var.document(uid).setData({
		"sugars" : sugars,
		"name" : name,
		"strength" : strength,
	});
}

# Calling the Authenticator Class through the Loader Class
// Note: In the UI class:
onPressed: () async 
{  
	dynamic fetchedData = await Navigator.pushNamed(context, "/LoadingUser");
	print("Currently signed in: ${fetchedData["data"]}");
}, 

// Note: In the Loader class:
@override
void initState() { 
	super.initState();
	delayedRun();
}

Future<void> delayedRun() async
{
	dynamic currentUser = await Authenticate().signInAnon();
	Navigator.pop(context, {"data": currentUser});
}

# Creating Database Service
1. Inside the services folder, create a database.dart
2. import 'package:cloud_firestore/cloud_firestore.dart';
3. Create a class.
4. Inside the class create a final variable that will contain the uid.
5. Create a constructor that fetches the data.
6. Inside the class, create this variable:
	> final CollectionReference var = Firestore.instance.collection('name of your collection');
	Note: This acts as your collection reference in the firestore.

// Note: Call the function in the authenticator service when registering a user.
await Database(uid: user.uid).updateUserData('e','New Member',50);

// Note: var is the collection reference.
	 - uid is to determine which user has the data

# Creating model for the extracted data from the database.
1. Create a file in your models folder.
2. Create your own class with final variables/properties representing each data you want to extract.
3. Create constructors that will pass on the data to the variables.

# Putting data in your custom model. (ALL USER) 
1. Import your custom model.
2. Create this code:
// Note: Example only
List<*CustomModelName*> var(QuerySnapshot snapshot)
{
return snapshot.documents.map((doc){
  return CustomModelName(
	property1: doc.data["databaseproperty1"] ?? '',
	property2: doc.data["databaseproperty2"] ?? '',
	property3: doc.data["databaseproperty3"] ?? '',
  );
}).toList();
}
Notes: > the ?? means that if the data is null, it will return a '' or 0 instead. (Depends on the data type of the variable);
	 > QuerySnapshot gets all the data in the database.
	 > The Stream will determine which document.
 
 
# Streaming Data from the Database (ALL USER)
Stream<List<*CustomModelName*>> get var
{
return var.snapshots().map(*variableNameOfList*); 
} 

# Putting Data in your custom model. (SINGLE USER)
CustomModelName var(DocumentSnapshot snapshot)
{
return CustomModelName(
	property1: snapshot.data['name of database property'],
	property1: snapshot.data['name of database property'],
	property1: snapshot.data['name of database property'],
)
}
  
# Streaming Data from the Database (SINGLE USER)
Stream<CustomModelName> get brewData 
{
return var.document(uid).snapshots().map(*variableNameOfModel*);
}

// Note: the var here is the collection reference.

# Using the Provider to get the Streamed Data
1. import the service where you streamed the data.
2. import cloud firestore.
3. Wrap your primary widget with StreamProvider<>.value.
4. Create a value property that contains the Database/Authenticate class and the fetched data.
// Note: example code:
return StreamProvider<List<*CustomModelName*>>.value(
	  value: Database().var, 
// Note: the var is whatever the variable is fetched by get.
	  
// Note: Once you do this, you can now access the data through...
// Note: if all data from the users
final dynamic myData = Provider.of<List<Model>>(context); 
// Note: Example Code for looping through the data of the listed model 
for(var x in myData)
{
	print(x.property);
}

// Note: if single data from the user
final dynamic myData = Provider.of<Model>(context);  
print(myData.property);

# Other way of getting the data through StreamBuilder
1. Wrap your primary widget with StreamBuilder<*CustomModelName*>
2. Create a stream property that holds the Database service class.
3. Create a builder property.
 builder: (context,snapshot) {
	 return ANY_WIDGET_TREE;
 }
// Note: The snapshop here holds the data.
	> to access the data, just do this: snapshot.data
	> if accessing a property: snapshot.data.property

 

 
 










